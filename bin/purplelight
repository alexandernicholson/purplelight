#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'json'
require 'mongo'
require_relative '../lib/purplelight'

options = {
  format: :jsonl,
  compression: :zstd,
  partitions: nil,
  batch_size: 2000,
  output: nil,
  query: {},
  sharding: { mode: :by_size, part_bytes: 256 * 1024 * 1024, prefix: nil },
  resume: { enabled: true },
  read_preference: nil,
  read_tags: nil,
  dry_run: false
}

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: purplelight snapshot [options]'

  opts.on('-u', '--uri URI', 'MongoDB connection URI (required)') { |v| options[:uri] = v }
  opts.on('-d', '--db NAME', 'Database name (required)') { |v| options[:db] = v }
  opts.on('-c', '--collection NAME', 'Collection name (required)') { |v| options[:collection] = v }
  opts.on('-o', '--output PATH', 'Output directory or file (required)') { |v| options[:output] = v }
  opts.on('-f', '--format FORMAT', 'Format: jsonl|csv|parquet (default jsonl)') { |v| options[:format] = v.to_sym }
  opts.on('--compression NAME', 'Compression: zstd|gzip|none') { |v| options[:compression] = v.to_sym }
  opts.on('--partitions N', Integer, 'Number of partitions') { |v| options[:partitions] = v }
  opts.on('--batch-size N', Integer, 'Mongo batch size (default 2000)') { |v| options[:batch_size] = v }
  opts.on('--by-size BYTES', Integer, 'Shard by size (bytes); default 268435456') do |v|
    options[:sharding] = { mode: :by_size, part_bytes: v }
  end
  opts.on('--single-file', 'Write a single output file') { options[:sharding] = { mode: :single_file } }
  opts.on('--prefix NAME', 'Output file prefix') do |v|
    options[:sharding] ||= {}
    options[:sharding][:prefix] = v
  end
  opts.on('-q', '--query JSON', 'Filter query as JSON') { |v| options[:query] = JSON.parse(v) }
  opts.on('--read-preference MODE',
          'Read preference mode: primary|primary_preferred|secondary|secondary_preferred|nearest') do |v|
    options[:read_preference] = v.to_sym
  end
  opts.on('--read-tags TAGS',
          'Comma-separated key=value list to target tagged nodes (e.g., nodeType=ANALYTICS,region=EAST)') do |v|
    tags = {}
    v.split(',').each do |pair|
      k, val = pair.split('=', 2)
      next if k.nil? || val.nil?

      tags[k] = val
    end
    options[:read_tags] = tags unless tags.empty?
  end
  opts.on('--dry-run', 'Parse options and print effective read preference JSON, then exit') { options[:dry_run] = true }
  opts.on('--version', 'Show version') do
    puts Purplelight::VERSION
    exit 0
  end
  opts.on('-h', '--help', 'Show help') do
    puts opts
    exit 0
  end
end

begin
  parser.parse!(ARGV)
rescue OptionParser::ParseError => e
  warn e.message
  warn parser
  exit 1
end

%i[uri db collection output].each do |k|
  next unless options[k].nil? || options[k].to_s.empty?

  warn "Missing required option: --#{k}"
  warn parser
  exit 1
end

effective_read = nil
if options[:read_tags]
  effective_read = { mode: options[:read_preference] || :secondary, tag_sets: [options[:read_tags]] }
elsif options[:read_preference]
  effective_read = { mode: options[:read_preference] }
end

if options[:dry_run]
  puts JSON.generate({ read_preference: effective_read })
  exit 0
end

client = Mongo::Client.new(options[:uri])
options[:partitions] ||= (Etc.respond_to?(:nprocessors) ? [Etc.nprocessors * 2, 4].max : 4)

ok = Purplelight.snapshot(
  client: client.use(options[:db]),
  collection: options[:collection],
  output: options[:output],
  format: options[:format],
  compression: options[:compression],
  partitions: options[:partitions],
  batch_size: options[:batch_size],
  query: options[:query],
  sharding: options[:sharding],
  read_preference: effective_read || options[:read_preference],
  resume: { enabled: true },
  on_progress: ->(s) { warn("progress: #{s.to_json}") }
)

exit(ok ? 0 : 1)
